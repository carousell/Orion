package generator

import (
	"bytes"
	"fmt"
	"strconv"
	"strings"
	"text/template"

	"github.com/carousell/Orion/protoc-gen-orion/internal/ports/inputs"
)

// constants for Orion protoc generator
const (
	ORION       = "ORION"
	URL         = "URL"
	DELIM       = ":"
	OPTION      = "OPTION"
	MIDDLEWARE  = "MIDDLEWARE"
	MIDDLEWARES = "MIDDLEWARES"
)

type commentsInfo struct {
	Method     string
	Path       string
	Decoder    bool
	Encoder    bool
	Option     bool
	Middleware bool
	Value      string
}

type data struct {
	FileName    string
	PackageName string
	Services    []*service
}

type service struct {
	ServName       string
	ServiceDescVar string
	Encoders       []*encoder
	Decoders       []*decoder
	Handlers       []*handler
	Options        []*orionOption
	Middlewares    []*orionMiddleware
	Streams        []*stream
}

type encoder struct {
	SvcName    string
	MethodName string
	Path       string
	Methods    string
}
type decoder struct {
	SvcName    string
	MethodName string
}
type handler struct {
	SvcName    string
	MethodName string
	Path       string
}
type stream struct {
	SvcName      string
	MethodName   string
	Path         string
	ClientStream bool
	ServerStream bool
	Methods      string
}

type orionOption struct {
	SvcName    string
	MethodName string
	OptionType string
}

type orionMiddleware struct {
	SvcName    string
	MethodName string
	Names      string
}

var tmpl = `// Code generated by protoc-gen-orion. DO NOT EDIT.
// source: {{ .FileName }}

package {{ .PackageName }}
{{ if .Services }}
import (
	orion "github.com/carousell/Orion/orion"
)

// If you see error please update your orion-protoc-gen by running 'go get -u github.com/carousell/Orion/protoc-gen-orion'
var _ = orion.ProtoGenVersion1_0
{{ end }}
{{ range .Services -}}
// Encoders
{{ range .Encoders }}
// Register{{.SvcName}}{{.MethodName}}Encoder registers the encoder for {{.MethodName}} method in {{.SvcName}}
// it registers HTTP {{ if .Path }} path {{.Path}} {{ end }}with {{.Methods}} methods
func Register{{.SvcName}}{{.MethodName}}Encoder(svr orion.Server, encoder orion.Encoder) {
	orion.RegisterEncoders(svr, "{{.SvcName}}", "{{.MethodName}}", []string{ {{- .Methods -}} }, "{{.Path}}", encoder)
}
{{ end }}
// Handlers
{{ range .Handlers }}
// Register{{.SvcName}}{{.MethodName}}Handler registers the handler for {{.MethodName}} method in {{.SvcName}}
func Register{{.SvcName}}{{.MethodName}}Handler(svr orion.Server, handler orion.HTTPHandler) {
	orion.RegisterHandler(svr, "{{.SvcName}}", "{{.MethodName}}", "{{.Path}}", handler)
}
{{ end }}
// Decoders
{{ range .Decoders }}
// Register{{.SvcName}}{{.MethodName}}Decoder registers the decoder for {{.MethodName}} method in {{.SvcName}}
func Register{{.SvcName}}{{.MethodName}}Decoder(svr orion.Server, decoder orion.Decoder) {
	orion.RegisterDecoder(svr, "{{.SvcName}}", "{{.MethodName}}", decoder)
}
{{ end }}
// Streams
{{ range .Streams }}
// {{ . }}
{{ end }}
// Register{{.ServName}}OrionServer registers {{.ServName}} to Orion server
// Services need to pass either ServiceFactory or ServiceFactoryV2 implementation
func Register{{.ServName}}OrionServer(sf interface{}, orionServer orion.Server) error {
	err := orionServer.RegisterService(&{{.ServiceDescVar}}, sf)
	if err != nil {
		return err
	}
{{ range .Encoders }}
	Register{{.SvcName}}{{.MethodName}}Encoder(orionServer, nil)
{{- end }}
{{- range .Options }}
	orion.RegisterMethodOption(orionServer, "{{.SvcName}}", "{{.MethodName}}", "{{.OptionType}}")
{{- end }}
{{- range .Middlewares }}
	orion.RegisterMiddleware(orionServer, "{{.SvcName}}", "{{.MethodName}}", {{.Names}})
{{- end }}
	return nil
}

// DefaultEncoder
func Register{{.ServName}}DefaultEncoder(svr orion.Server, encoder orion.Encoder) {
	orion.RegisterDefaultEncoder(svr, "{{.ServName}}", encoder)
}

// DefaultDecoder
func Register{{.ServName}}DefaultDecoder(svr orion.Server, decoder orion.Decoder) {
	orion.RegisterDefaultDecoder(svr, "{{.ServName}}", decoder)
}
{{ end }}
`

type GeneratorResponse struct {
	Name    string
	Content string
}

func GenerateFile(pf inputs.ProtoFile) (GeneratorResponse, error) {
	d := &data{
		FileName:    pf.Name,
		PackageName: pf.PackageName,
		Services:    generateService(pf),
	}

	t := template.New("file")
	t, err := t.Parse(tmpl)
	if err != nil {
		return GeneratorResponse{}, fmt.Errorf("parse template")
	}

	buf := new(bytes.Buffer)
	if err = t.Execute(buf, d); err != nil {
		return GeneratorResponse{}, fmt.Errorf("execute template")
	}

	return GeneratorResponse{
		Name:    d.FileName + ".orion.pb.go",
		Content: buf.String(),
	}, nil
}

func generateService(pf inputs.ProtoFile) []*service {
	var services []*service

	commentPathMap := extractComments(pf)
	for index, svc := range pf.Service {

		servName := GoCamelCase(svc.Name)
		serviceDescVar := "_" + servName + "_serviceDesc"

		s := new(service)
		s.Encoders = make([]*encoder, 0)
		s.Handlers = make([]*handler, 0)
		s.Decoders = make([]*decoder, 0)
		s.Options = make([]*orionOption, 0)
		s.Middlewares = make([]*orionMiddleware, 0)
		s.Streams = make([]*stream, 0)
		s.ServiceDescVar = serviceDescVar
		s.ServName = servName
		services = append(services, s)

		// ** --- START -- Find comments in grpc services
		path := fmt.Sprintf("6,%d", index) // 6 means service.
		for i, method := range svc.Method {
			commentPath := fmt.Sprintf("%s,2,%d", path, i) // 2 means method in a service.
			if comments, ok := commentPathMap[commentPath]; ok {
				for _, comment := range comments {
					// ** --- END -- Find comments in grpc services

					if option := parseComment(comment); option != nil {
						if method.ClientStreaming || method.ServerStreaming {
							str := new(stream)
							str.SvcName = svc.Name
							str.MethodName = method.Name
							str.ClientStream = method.ClientStreaming
							str.ServerStream = method.ServerStreaming
							if option.Encoder || option.Decoder {
								str.Path = option.Path
								str.Methods = option.Method
							}
							s.Streams = append(s.Streams, str)
						} else { // dont add others for streaming use cases
							if option.Encoder {
								methods := strings.Split(option.Method, "/")
								for i := range methods {
									if strings.ToLower(methods[i]) == "options" {
									}
									methods[i] = "\"" + methods[i] + "\""
								}
								methodsString := strings.Join(methods, ", ")

								// populate encoder
								enc := new(encoder)
								enc.SvcName = svc.Name
								enc.MethodName = method.Name
								enc.Path = option.Path
								enc.Methods = methodsString
								s.Encoders = append(s.Encoders, enc)

								// popluate handler
								han := new(handler)
								han.SvcName = svc.Name
								han.MethodName = method.Name
								han.Path = option.Path
								s.Handlers = append(s.Handlers, han)
							}

							if option.Decoder {
								// popluate decoder
								dec := new(decoder)
								dec.SvcName = svc.Name
								dec.MethodName = method.Name
								s.Decoders = append(s.Decoders, dec)
							}

							if option.Option {
								opt := new(orionOption)
								opt.SvcName = svc.Name
								opt.MethodName = method.Name
								opt.OptionType = strings.TrimSpace(option.Value)
								s.Options = append(s.Options, opt)
							}

							if option.Middleware {
								mid := new(orionMiddleware)
								mid.SvcName = svc.Name
								mid.MethodName = method.Name
								names := strings.Split(option.Value, ",")
								for i := range names {
									names[i] = "\"" + strings.TrimSpace(names[i]) + "\""
								}
								mid.Names = strings.Join(names, ", ")
								s.Middlewares = append(s.Middlewares, mid)
							}
						}
					}
				}
			}
		}
	}

	return services
}

func parseCommentURL(parts []string) *commentsInfo {
	if len(parts) > 2 {
		values := strings.SplitN(strings.TrimSpace(parts[2]), " ", 2)
		if len(values) == 2 {
			return &commentsInfo{
				Method:  strings.ToUpper(values[0]),
				Path:    values[1],
				Encoder: true,
				Decoder: true,
			}
		}
		return &commentsInfo{
			Method:  strings.ToUpper(values[0]),
			Path:    "",
			Encoder: true,
			Decoder: true,
		}
	}
	return &commentsInfo{
		Decoder: true,
	}
}

func parseMiddlewares(parts []string) *commentsInfo {
	if len(parts) > 2 {
		return &commentsInfo{
			Middleware: true,
			Value:      parts[2],
		}
	}
	return nil
}

func parseCommentOptions(parts []string) *commentsInfo {
	if len(parts) > 2 {
		return &commentsInfo{
			Option: true,
			Value:  strings.ToUpper(parts[2]),
		}
	}
	return nil
}

func parseComment(comment string) *commentsInfo {
	parts := strings.SplitN(comment, DELIM, 3)
	if len(parts) > 1 {
		if ORION == strings.ToUpper(strings.TrimSpace(parts[0])) {
			switch strings.ToUpper(strings.TrimSpace(parts[1])) {
			case URL:
				return parseCommentURL(parts)
			case OPTION:
				return parseCommentOptions(parts)
			case MIDDLEWARES:
				fallthrough
			case MIDDLEWARE:
				return parseMiddlewares(parts)
			}
		}
	}
	return nil
}

type commentPathMap map[string]leadingComments

type leadingComments = []string

func extractComments(pf inputs.ProtoFile) commentPathMap {
	comments := make(commentPathMap)
	for _, loc := range pf.Location {
		var p []string
		for _, n := range loc.Path {
			p = append(p, strconv.Itoa(int(n)))
		}
		comments[strings.Join(p, ",")] = strings.Split(loc.Comments, "\n")
	}
	return comments
}
