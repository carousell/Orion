// protoc-gen-orion is a plugin for the Google protocol buffer compiler to generate
// Orion Go code.  Run it by building this program and putting it in your path with
// the name
// 	protoc-gen-orion
//
// The generated code is documented in the package comment for
// the library.
package main

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"strconv"
	"strings"
	"text/template"

	"github.com/golang/protobuf/proto"
	"github.com/golang/protobuf/protoc-gen-go/descriptor"
	"github.com/golang/protobuf/protoc-gen-go/generator"
	plugin "github.com/golang/protobuf/protoc-gen-go/plugin"
)

// constants for Orion protoc generator
const (
	ORION       = "ORION"
	URL         = "URL"
	DELIM       = ":"
	OPTION      = "OPTION"
	MIDDLEWARE  = "MIDDLEWARE"
	MIDDLEWARES = "MIDDLEWARES"
)

type commentsInfo struct {
	Method     string
	Path       string
	Decoder    bool
	Encoder    bool
	Option     bool
	Middleware bool
	Value      string
}

type data struct {
	FileName    string
	PackageName string
	Services    []*service
}

type service struct {
	ServName       string
	ServiceDescVar string
	Encoders       []*encoder
	Decoders       []*decoder
	Handlers       []*handler
	Options        []*orionOption
	Middlewares    []*orionMiddleware
	Streams        []*stream
}

type encoder struct {
	SvcName    string
	MethodName string
	Path       string
	Methods    string
}
type decoder struct {
	SvcName    string
	MethodName string
}
type handler struct {
	SvcName    string
	MethodName string
	Path       string
}
type stream struct {
	SvcName      string
	MethodName   string
	Path         string
	ClientStream bool
	ServerStream bool
	Methods      string
}

type orionOption struct {
	SvcName    string
	MethodName string
	OptionType string
}

type orionMiddleware struct {
	SvcName    string
	MethodName string
	Names      string
}

var tmpl = `// Code generated by protoc-gen-orion. DO NOT EDIT.
// source: {{ .FileName }}

package {{ .PackageName }}
{{ if .Services }}
import (
	orion "github.com/carousell/Orion/orion"
)

// If you see error please update your orion-protoc-gen by running 'go get -u github.com/carousell/Orion/protoc-gen-orion'
var _ = orion.ProtoGenVersion1_0
{{ end }}
{{ range .Services -}}
// Encoders
{{ range .Encoders }}
// Register{{.SvcName}}{{.MethodName}}Encoder registers the encoder for {{.MethodName}} method in {{.SvcName}}
// it registers HTTP {{ if .Path }} path {{.Path}} {{ end }}with {{.Methods}} methods
func Register{{.SvcName}}{{.MethodName}}Encoder(svr orion.Server, encoder orion.Encoder) {
	orion.RegisterEncoders(svr, "{{.SvcName}}", "{{.MethodName}}", []string{ {{- .Methods -}} }, "{{.Path}}", encoder)
}
{{ end }}
// Handlers
{{ range .Handlers }}
// Register{{.SvcName}}{{.MethodName}}Handler registers the handler for {{.MethodName}} method in {{.SvcName}}
func Register{{.SvcName}}{{.MethodName}}Handler(svr orion.Server, handler orion.HTTPHandler) {
	orion.RegisterHandler(svr, "{{.SvcName}}", "{{.MethodName}}", "{{.Path}}", handler)
}
{{ end }}
// Decoders
{{ range .Decoders }}
// Register{{.SvcName}}{{.MethodName}}Decoder registers the decoder for {{.MethodName}} method in {{.SvcName}}
func Register{{.SvcName}}{{.MethodName}}Decoder(svr orion.Server, decoder orion.Decoder) {
	orion.RegisterDecoder(svr, "{{.SvcName}}", "{{.MethodName}}", decoder)
}
{{ end }}
// Streams
{{ range .Streams }}
// {{ . }}
{{ end }}
// Register{{.ServName}}OrionServer registers {{.ServName}} to Orion server
// Services need to pass either ServiceFactory or ServiceFactoryV2 implementation
func Register{{.ServName}}OrionServer(sf interface{}, orionServer orion.Server) error {
	err := orionServer.RegisterService(&{{.ServiceDescVar}}, sf)
	if err != nil {
		return err
	}
{{ range .Encoders }}
	Register{{.SvcName}}{{.MethodName}}Encoder(orionServer, nil)
{{- end }}
{{- range .Options }}
	orion.RegisterMethodOption(orionServer, "{{.SvcName}}", "{{.MethodName}}", "{{.OptionType}}")
{{- end }}
{{- range .Middlewares }}
	orion.RegisterMiddleware(orionServer, "{{.SvcName}}", "{{.MethodName}}", {{.Names}})
{{- end }}
	return nil
}

// DefaultEncoder
func Register{{.ServName}}DefaultEncoder(svr orion.Server, encoder orion.Encoder) {
	orion.RegisterDefaultEncoder(svr, "{{.ServName}}", encoder)
}

// DefaultDecoder
func Register{{.ServName}}DefaultDecoder(svr orion.Server, decoder orion.Decoder) {
	orion.RegisterDefaultDecoder(svr, "{{.ServName}}", decoder)
}
{{ end }}
`

// Error reports a problem, including an error, and exits the program.
func logError(err error, msgs ...string) {
	s := strings.Join(msgs, " ") + ":" + err.Error()
	log.Print("protoc-gen-orion: error:", s)
	os.Exit(1)
}

// Fail reports a problem and exits the program.
func logFail(msgs ...string) {
	s := strings.Join(msgs, " ")
	log.Print("protoc-gen-orion: error:", s)
	os.Exit(1)
}

func main() {
	data, err := ioutil.ReadAll(os.Stdin)
	if err != nil {
		logError(err, "reading input")
	}

	request := new(plugin.CodeGeneratorRequest)
	if err := proto.Unmarshal(data, request); err != nil {
		logError(err, "parsing input proto")
	}

	if len(request.FileToGenerate) == 0 {
		logFail("no files to generate")
	}
	filesToGenerate := make(map[string]bool)
	for _, v := range request.FileToGenerate {
		filesToGenerate[v] = true
	}

	response := new(plugin.CodeGeneratorResponse)
	response.File = make([]*plugin.CodeGeneratorResponse_File, 0)

	for _, file := range request.GetProtoFile() {
		if _, ok := filesToGenerate[file.GetName()]; ok {
			// check if file has any service
			if len(file.Service) > 0 {
				f := generateFile(populate(NewProtoFile(file)))
				response.File = append(response.File, f)
			}
		}
	}

	// Send back the results.
	data, err = proto.Marshal(response)
	if err != nil {
		logError(err, "failed to marshal output proto")
	}
	_, err = os.Stdout.Write(data)
	if err != nil {
		logError(err, "failed to write output proto")
	}
}

func generateFile(d *data) *plugin.CodeGeneratorResponse_File {
	t := template.New("file")
	t, err := t.Parse(tmpl)
	if err != nil {
		logError(err, "failed parsing template")
	}

	buf := new(bytes.Buffer)
	err = t.Execute(buf, d)
	if err != nil {
		logError(err, "failed parsing template")
	}

	file := new(plugin.CodeGeneratorResponse_File)
	file.Content = proto.String(buf.String())
	file.Name = proto.String(d.FileName + ".orion.pb.go")
	return file
}

func populate(pf ProtoFile) *data {
	return &data{
		FileName:    pf.Name,
		PackageName: pf.PackageName,
		Services:    generateService(pf),
	}
}

func generateService(pf ProtoFile) []*service {
	var services []*service

	commentPathMap := extractComments(pf)
	for index, svc := range pf.Service {

		origServName := svc.Name
		servName := generator.CamelCase(origServName) // use the same logic from go-grpc generator
		serviceDescVar := "_" + servName + "_serviceDesc"

		s := new(service)
		s.Encoders = make([]*encoder, 0)
		s.Handlers = make([]*handler, 0)
		s.Decoders = make([]*decoder, 0)
		s.Options = make([]*orionOption, 0)
		s.Middlewares = make([]*orionMiddleware, 0)
		s.Streams = make([]*stream, 0)
		s.ServiceDescVar = serviceDescVar
		s.ServName = servName
		services = append(services, s)

		// ** --- START -- Find comments in grpc services
		path := fmt.Sprintf("6,%d", index) // 6 means service.
		for i, method := range svc.Method {
			commentPath := fmt.Sprintf("%s,2,%d", path, i) // 2 means method in a service.
			if comments, ok := commentPathMap[commentPath]; ok {
				for _, comment := range comments {
					// ** --- END -- Find comments in grpc services

					if option := parseComment(comment); option != nil {
						if method.ClientStreaming || method.ServerStreaming {
							str := new(stream)
							str.SvcName = svc.Name
							str.MethodName = method.Name
							str.ClientStream = method.ClientStreaming
							str.ServerStream = method.ServerStreaming
							if option.Encoder || option.Decoder {
								str.Path = option.Path
								str.Methods = option.Method
							}
							s.Streams = append(s.Streams, str)
						} else { // dont add others for streaming use cases
							if option.Encoder {
								methods := strings.Split(option.Method, "/")
								for i := range methods {
									if strings.ToLower(methods[i]) == "options" {
									}
									methods[i] = "\"" + methods[i] + "\""
								}
								methodsString := strings.Join(methods, ", ")

								// populate encoder
								enc := new(encoder)
								enc.SvcName = svc.Name
								enc.MethodName = method.Name
								enc.Path = option.Path
								enc.Methods = methodsString
								s.Encoders = append(s.Encoders, enc)

								// popluate handler
								han := new(handler)
								han.SvcName = svc.Name
								han.MethodName = method.Name
								han.Path = option.Path
								s.Handlers = append(s.Handlers, han)
							}

							if option.Decoder {
								// popluate decoder
								dec := new(decoder)
								dec.SvcName = svc.Name
								dec.MethodName = method.Name
								s.Decoders = append(s.Decoders, dec)
							}

							if option.Option {
								opt := new(orionOption)
								opt.SvcName = svc.Name
								opt.MethodName = method.Name
								opt.OptionType = strings.TrimSpace(option.Value)
								s.Options = append(s.Options, opt)
							}

							if option.Middleware {
								mid := new(orionMiddleware)
								mid.SvcName = svc.Name
								mid.MethodName = method.Name
								names := strings.Split(option.Value, ",")
								for i := range names {
									names[i] = "\"" + strings.TrimSpace(names[i]) + "\""
								}
								mid.Names = strings.Join(names, ", ")
								s.Middlewares = append(s.Middlewares, mid)
							}
						}
					}
				}
			}
		}
	}

	return services
}

func parseCommentURL(parts []string) *commentsInfo {
	if len(parts) > 2 {
		values := strings.SplitN(strings.TrimSpace(parts[2]), " ", 2)
		if len(values) == 2 {
			return &commentsInfo{
				Method:  strings.ToUpper(values[0]),
				Path:    values[1],
				Encoder: true,
				Decoder: true,
			}
		}
		return &commentsInfo{
			Method:  strings.ToUpper(values[0]),
			Path:    "",
			Encoder: true,
			Decoder: true,
		}
	}
	return &commentsInfo{
		Decoder: true,
	}
}

func parseMiddlewares(parts []string) *commentsInfo {
	if len(parts) > 2 {
		return &commentsInfo{
			Middleware: true,
			Value:      parts[2],
		}
	}
	return nil
}

func parseCommentOptions(parts []string) *commentsInfo {
	if len(parts) > 2 {
		return &commentsInfo{
			Option: true,
			Value:  strings.ToUpper(parts[2]),
		}
	}
	return nil
}

func parseComment(comment string) *commentsInfo {
	parts := strings.SplitN(comment, DELIM, 3)
	if len(parts) > 1 {
		if ORION == strings.ToUpper(strings.TrimSpace(parts[0])) {
			switch strings.ToUpper(strings.TrimSpace(parts[1])) {
			case URL:
				return parseCommentURL(parts)
			case OPTION:
				return parseCommentOptions(parts)
			case MIDDLEWARES:
				fallthrough
			case MIDDLEWARE:
				return parseMiddlewares(parts)
			}
		}
	}
	return nil
}

type CommentPathMap map[string]LeadingComments

type LeadingComments = []string

func extractComments(pf ProtoFile) CommentPathMap {
	comments := make(CommentPathMap)
	for _, loc := range pf.Location {
		var p []string
		for _, n := range loc.Path {
			p = append(p, strconv.Itoa(int(n)))
		}
		comments[strings.Join(p, ",")] = strings.Split(loc.Comments, "\n")
	}
	return comments
}

type ProtoFile struct {
	Name        string
	PackageName string
	Service     []ProtoFileService
	Location    []ProtoFileLocation
}

type ProtoFileService struct {
	Name   string
	Method []ProtoFileServiceMethod
}

type ProtoFileServiceMethod struct {
	Name            string
	ClientStreaming bool
	ServerStreaming bool
}

type ProtoFileLocation struct {
	Comments string
	Path     []int32
}

func NewProtoFile(file *descriptor.FileDescriptorProto) ProtoFile {
	pf := ProtoFile{
		Name:        file.GetName(),
		PackageName: strings.Replace(file.GetPackage(), ".", "_", 10),
	}
	for _, loc := range file.GetSourceCodeInfo().GetLocation() {
		if loc.LeadingComments == nil {
			continue
		}
		path := make([]int32, len(loc.GetPath()))
		copy(path, loc.GetPath())
		pfl := ProtoFileLocation{
			Comments: strings.TrimSuffix(loc.GetLeadingComments(), "\n"),
			Path:     path,
		}
		pf.Location = append(pf.Location, pfl)
	}
	for _, svc := range file.GetService() {
		pfs := ProtoFileService{
			Name: svc.GetName(),
		}
		for _, method := range svc.GetMethod() {
			pfsm := ProtoFileServiceMethod{
				Name:            method.GetName(),
				ClientStreaming: method.GetClientStreaming(),
				ServerStreaming: method.GetServerStreaming(),
			}
			pfs.Method = append(pfs.Method, pfsm)
		}
		pf.Service = append(pf.Service, pfs)
	}
	return pf
}
